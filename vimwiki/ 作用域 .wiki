# 在代码中变量被赋值(变量在赋值时创建,经赋值才能使用)的位置决定了这个变量名能被访问到的范围。原处改变对象并不会把变量划分为本地变量。
# 在默认情况下，一个函数的所有变量名都是与函数的命名空间相关联的。语义作用域。
# 内嵌的模块是全局作用域。全局作用域的作用范围仅限于单个文件。每次对函数的调用都创建了一个新的本地作用域。赋值的变量名除非声明为全局变量或非本地变量，否则均为本地变量。所有其他的变量名都可以归纳为本地，全局，内置。
# 交互模式运行的代码实际上真的输入到一个叫做__main__的内置模块中。
# LEGB法则：当在函数中使用未认证的变量名时，python搜索4个作用域「本地L，上层def或lambda的本地E，全局G，内置B」（仅对简单的变量名有效）
# 内置作用域通过一个名为__buildin__的标准库模块来实现。一半是内置的异常，一半是内置的函数。
# 一个模块文件的全局变量一旦被导入就成为这个模块对象的一个属性。导入文件，创建模块对象并赋值给文件名。全局变量和模块属性等效。
# 文件间进入通信的最好方法是通过调用函数传递参数然后得到返回值。accessor函数。
# 工厂函数：
{{{
    def maker(N):
        def action(X):
            return x ** N
        return action
    f = maker(2) #f为action函数，并保留N=2的状态信息。
    f(3) #3**2 = 9
    g = maker(3) #g为action函数，并保留N＝3的状态信息。
    g(3) #3**3 = 27
#本地作用域内的N被作为执行的状态信息保留下来。
    def maker(N):
        action = (lambda x: x**N)
        return action
    #同上，lambda创建函数对象并返回
    
    def f1():
        f2()
    def f2():
        ...
    f1() #在函数内部调用之后才定义的函数是可行的，只要第二个函数定义的运行是在第一个函数调用前就成。在def内部的代码直到这个函数运行时（而非定义时）才会被验证。
    }}}
# 作用域与带有循环变量的默认参数相比较：
# 如果lambda或者def定义在函数内的循环中，且引用循环变量，则循环产生的函数将会有相同的值，即最后一次循环完成时被引用变量的值。因为嵌套作用域中的变量在嵌套的函数被调用时才进制查找，为了让这类代码能够工作，必须使用默认参数把当前值传递给嵌套作用域的变量。因为默认参数是嵌套函数创建时评估，而作用域则是嵌套函数调用时评估。
{{{
    def makeAction():
        acts=[]
        for i in range(5):
            acts.append(lambda x, i=i: i**x)
        return acts
    acts=makeAction()
    acts[0](2)
}}}
# 使用nonlocal语句，嵌套的def可以对嵌套函数中的名称进制写入访问。
{{{
    与global不赋：
    ＃执行nonlocal时，名称必须已经在嵌套的def作用域赋值过，否则错误
    ＃nonlocal限制使用域查找仅为嵌套的def。
    def tester(start):
        state=start
        def nested(label):
            nonlocal state
            print(label,state)
            state += 1
        return nested
    #nonlocal语句允许在内存中保持可变状态的多个副本。
    }}}
