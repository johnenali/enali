# map把一个函数映射遍一个序列，列表解析把一个表达式映射遍一个序列。lambda算子可以将表达式生成函数。
# 可在列表解析中编写任意数量的嵌套的for循环，并且每个都有可选的if测试。
# 生成器函数：使用yield语句一次返回一个结果。自动在生成值的时刻挂起并继续函数的执行。在挂起时保存的状态包含它们的整个本地作用域。
# yield x：是表达式，而不是语句。
# 生成器表达式：(x ** 2 for x in range(4))不是在内存中构建结果，而是返回一个生成器对象，这个对象将会支持迭代协议并在任意的迭代环境中操作中。若在其他的括号中，自身括号可省略。是单迭代器对象。
# 从某种意义讲，集合解析和字典解析只是把生成器表达式传递给类型名的语法糖。
# time.clock()为记录当前时间点。{{{ start = time.clock(); stop = time.clock(); start - stod}}}
# 事实上不可能猜测哪种方法会执行的最好，最好的办法是在自己的计算机上，用自己的python版本，对自己的代码计时。
# 要优化python代码，第一件事就是不要优化python代码！首先为了可读性和简单性而编写代码，然后，如果需要的话并且只有在需要的时候，再优化。
# 在相对性能方面，列表解析在大多数情况下表现最好，当使用内置函数时，map表现更好。
# 陷阱：
{{{
    1，本地变量是静态检测的。或者说变量的作用域是编译时，而非运行时。
    X=99
    def selector():
        print(X)
        X=88
    #编译时，确定X为本地作用域（在函数内赋值），但运行时，print（X）会提示找不到X。即，被赋值的变量名在函数内部是当作本地变量对待的，而不是仅仅在赋值以后的语句中才被当作是本地变量。
    2，默认参数是在def语句运行时评估并保存的，是函数本身的特征，而不是在函数调用时。即若函数改变可变的默认参数，则每次调用时，改变将累加。
}}}
