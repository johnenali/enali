# 模块往往对应于python程序文件。
# {{{ import numpy as np; from matlibplot import plot; }}}
# 在一个模块文件的顶层定义的所有变量名都成了被导入的模块对象的属性，全局作用域变成了模块对名的命名空间。
# python程序架构：一个程序是一个模块的系统。它有一个顶层脚本文件（启动时可运行程序）以及多个模块文件（用来导入工具库）。脚本和模块都是包含python语句的文本文件，尽管在模块中的语句通常都是创建之后使用的对象。
# import同def也是隐性赋值语句，创建模块对象并赋值给变量名。模块名：1，识别加载的外部文档，2，被赋值以模块对象。
# 模块导入步骤：1，搜索； 2，编译； 3，运行。（编译可选，对于.pyc的中间码模块）
# python把载入的模块存储到一个名sys.modules的表中，并在一次导入操作的开始检查表。如果模块不存在，将会启动一个三个步骤的过程。
# 模块搜索路径：程序的主目录， PYTHONPATH目录， 标准链接库目录， 任何.pth文件的内容。
# from把一个模块的变量名复制到另一个作用域，而无需使用属性语法。from abc import *会污染导入的作用域。
# 模块即命名空间，同类。
{{{
    1，模块语句会在首次导入时执行。
    2，顶层的赋值语句会创建模块属性。通过点号运算获取
    3，模块的命名空间能通过属性__dict__或dir(M)获取。
    4，模块是一个独立的作用域。
    }}}
# 作用域绝对不会被函数调用或模块导入影响。
# imp.reload会强制已加载的模块的代码重新载入并重新执行。
# 事实上，包导入是把计算机上的目录变成另一个python命名空间，而属性则对应于目录中所包含的子目录和模块文件。点号路径对应于机器上目录层次的路径。
# {{{ import dir1.dir2.mod }}}
# 如果选择使用包导入，就必须多遵循一条约束：包导入语句的路径中的每个目录内都必须有___init___.py这个文件，否则导入包会失败。文件扮演包初始化的钩子、替目录产生模块命名空间以及使用目录导入时实现from ＊行为的角色。在文件内通过使用__all__列表定义目录以from ＊语句形式导入时，需要导出什么。
# python3.0：绝对导入（默认跳过包自己的目录），相对导入（显式要求导入只搜索包的目录）{{{ from . import spam }}}
# 如果文件是以顶层程序文件执行，在启动时，__name__就会设置为字符串"__main__", 如果文件被导入，__name__就会改设成模块名。可用于编写自我测试代码。
# 内省：{{{ M.name  M.__dict__['name']  sys.modules['M'].name   getattr(M, 'name')}}}
# exec:执行字符串所代表的命令。
# 如果要重载模块A，但A导入模块B和C，此时重载只适用于A，而非B和C。
# 导入时，顶层代码导入时顺序执行，但函数或类代码则是调用时运行。
# reload不影响from导入。
